/-
Copyright (c) 2024 ArkLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import ArkLib.ProofSystem.ConstraintSystem.R1CS
import ArkLib.Data.MvPolynomial.Multilinear
import ArkLib.ProofSystem.Sumcheck.Spec.General
import ArkLib.ProofSystem.Component.SendWitness
import ArkLib.ProofSystem.Component.RandomQuery
import ArkLib.ProofSystem.Component.SendClaim
import ArkLib.ProofSystem.Component.CheckClaim

/-!
  # The Spartan PIOP (Polynomial Interactive Oracle Proof)

  The protocol is parametrized by the following parameters:

  - `R` is the underlying ring, required to be a finite integral domain.
  - `n := 2 ^ ‚Ñì_n` is the number of variables in the R1CS relation.
  - `m := 2 ^ ‚Ñì_m` is the number of constraints in the R1CS relation.
  - `n_w := 2 ^ ‚Ñì_w` is the number of witness variables, where `‚Ñì_w < ‚Ñì_n`.

  Note that all dimensions are required to be powers of two.

  (Maybe we shouldn't do this? And do the padding explicitly, so we can handle arbitrary
  dimensions?)

  It is used to prove the correctness of R1CS relations: `(A *·µ• ùï´) * (B *·µ• ùï´) = (C *·µ• ùï´)`, where:
  - `A, B, C : Matrix (Fin m) (Fin n) R` are the R1CS constraint matrices.
  - `ùï© : Fin (n - n_w) ‚Üí R` is the public input.
  - `ùï® : Fin n_w ‚Üí R` is the private witness.
  - `ùï´ = ùï© ‚Äñ ùï®` is the concatenation of the public input `ùï©` and the private witness `ùï®`.
  - `*·µ•` denotes the standard matrix-vector product, and `*` denotes the component-wise product.

  The protocol may prove R1CS relations whose dimensions are not powers of two by zero-padding.
  (details in the `R1CS.lean` file)

  The protocol (described as a PIOP, before composing with poly commitments) proceeds as follows:

  **I. Interaction Phase:**

  - **Stage 0:** The oracle verifier may optionally receive oracle access to the multilinear
    extensions `MLE A, MLE B, MLE C : R[X Fin ‚Ñì_n][X Fin ‚Ñì_m]` of the R1CS matrices `A`, `B`, and
    `C`. Otherwise, the oracle verifier may see the matrices `A`, `B`, and `C` directly (as part of
    the input statement).

  - **Stage 1:** The prover sends the multilinear extension `MLE ùï® : R[X Fin n_w]` of the witness
    `w` to the verifier. The verifier sends back a challenge `œÑ : Fin ‚Ñì_m ‚Üí R`.

  - **Stage 2:** The prover and verifier engage in a sum-check protocol to verify the computation:
      `‚àë x ‚àà {0, 1}^‚Ñì_m, eqPoly ‚∏®œÑ, x‚∏© * (Aùï´ ‚∏®x‚∏© * Bùï´ ‚∏®x‚∏© - Cùï´ ‚∏®x‚∏©) = 0`,

    where `Aùï´ ‚∏®X‚∏© = ‚àë y ‚àà {0, 1}^‚Ñì_m, (MLE A) ‚∏®X‚∏© ‚∏®y‚∏© * (MLE ùï´) ‚∏®y‚∏©`, and similarly for `Bùï´` and
    `Cùï´`.

    The sum-check protocol terminates with random challenges `r_x : Fin ‚Ñì_m ‚Üí R`, and the purported
    evaluation `e_x` of `eqPoly ‚∏®œÑ, r_x‚∏© * (Aùï´ ‚∏®r_x‚∏© * Bùï´ ‚∏®r_x‚∏© - Cùï´ ‚∏®r_x‚∏©)`.

  - **Stage 3:** The prover sends further evaluation claims to the verifier:

      `v_A = Aùï´ ‚∏®r_x‚∏©`, `v_B = Bùï´ ‚∏®r_x‚∏©`, `v_C = Cùï´ ‚∏®r_x‚∏©`

    The verifier sends back challenges `r_A, r_B, r_C : R`.

  - **Stage 4:** The prover and verifier engage in another sum-check protocol to verify the
    computation:

      `‚àë y ‚àà {0, 1}^‚Ñì_n, r_A * (MLE A) ‚∏®r_x, y‚∏© * (MLE ùï´) ‚∏®y‚∏© + r_B * (MLE B) ‚∏®r_x, y‚∏© *`
      `(MLE ùï´) ‚∏®y‚∏© + r_C * (MLE C) ‚∏®r_x, y‚∏© * (MLE ùï´) ‚∏®y‚∏© = r_A * v_A + r_B * v_B + r_C * v_C`

    The sum-check protocol terminates with random challenges `r_y : Fin ‚Ñì_n ‚Üí R`, and the purported
    evaluation `e_y` of

      `(r_A * (MLE A) ‚∏®r_x, r_y‚∏© + r_B * (MLE B) ‚∏®r_x, r_y‚∏© + r_C * (MLE C) ‚∏®r_x, r_y‚∏©) *`
      `(MLE ùï´) ‚∏®r_y‚∏©`.

  **II. Verification Phase:**

  1. The verifier makes a query to the polynomial oracle `MLE ùï®` at `r_y [‚Ñì_n - ‚Ñì_k :] : Fin ‚Ñì_k ‚Üí
     R`, and obtain an evaluation value `v_ùï® : R`.

  2. The verifier makes three queries to the polynomial oracles `MLE A, MLE B, MLE C` at `r_y ‚Äñ r_x
     : Fin (‚Ñì_n + ‚Ñì_m) ‚Üí R`, and obtain evaluation values `v_1, v_2, v_3 : R`.

  Alternatively, if the verifier does not receive oracle access, then it computes the evaluation
  values directly.

  3. The verifier computes `v_ùï´ := ùï© *·µ¢‚Çö (‚äó i, (1, r_y i))[: n - k] + (‚àè i < ‚Ñì_k, r_y i) * v_ùï®`,
     where `*·µ¢‚Çö` denotes the inner product, and `‚äó` denotes the tensor product.

  4. The verifier accepts if and only if both of the following holds:
    - `e_x = eqPoly ‚∏®œÑ, r_x‚∏© * (v_A * v_B - v_C)`
    - `e_y = (r_A * v_1 + r_B * v_2 + r_C * v_3) * v_ùï´`.

-/

open MvPolynomial Matrix

namespace Spartan

-- Note: this is the _padded_ Spartan protocol. The non-padded version will be defined via padding
-- to the nearest power of two

noncomputable section

/-- The public parameters of the (padded) Spartan protocol. Consists of the number of bits of the
  R1CS dimensions, and the number of bits of the witness variables. -/
structure PublicParams where
  ‚Ñì_m : ‚Ñï
  ‚Ñì_n : ‚Ñï
  ‚Ñì_w : ‚Ñï
  ‚Ñì_w_le_‚Ñì_n : ‚Ñì_w ‚â§ ‚Ñì_n := by omega

namespace PublicParams

/-- The R1CS dimensions / sizes are the powers of two of the public parameters. -/
def toSizeR1CS (pp : PublicParams) : R1CS.Size := {
  m := 2 ^ pp.‚Ñì_m
  n := 2 ^ pp.‚Ñì_n
  n_w := 2 ^ pp.‚Ñì_w
  n_w_le_n := Nat.pow_le_pow_of_le (by decide) pp.‚Ñì_w_le_‚Ñì_n
}

end PublicParams

namespace Spec

variable (R : Type) [CommRing R] [IsDomain R] [Fintype R] (pp : PublicParams)

variable {Œπ : Type} (oSpec : OracleSpec Œπ)

section Construction

/- The input types and relation is just the R1CS relation for the given size -/

/-- This unfolds to `ùï© : Fin (2 ^ ‚Ñì_n - 2 ^ ‚Ñì_w) ‚Üí R` -/
@[simp]
abbrev Statement := R1CS.Statement R pp.toSizeR1CS

/-- This unfolds to `A, B, C : Matrix (Fin 2 ^ ‚Ñì_m) (Fin 2 ^ ‚Ñì_n) R` -/
@[simp]
abbrev OracleStatement := R1CS.OracleStatement R pp.toSizeR1CS

/-- This unfolds to `ùï® : Fin 2 ^ ‚Ñì_w ‚Üí R` -/
@[simp]
abbrev Witness := R1CS.Witness R pp.toSizeR1CS

/-- This unfolds to `(A *·µ• ùï´) * (B *·µ• ùï´) = (C *·µ• ùï´)`, where `ùï´ = ùï© ‚Äñ ùï®` -/
@[simp]
abbrev relation := R1CS.relation R pp.toSizeR1CS

/-- The oracle interface for the input statement is the polynomial evaluation oracle of its
  multilinear extension. -/
-- For the input oracle statement, we define its oracle interface to be the polynomial evaluation
-- oracle of its multilinear extension.

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    oracle := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

-- For the input witness, we define its oracle interface to be the polynomial evaluation oracle of
-- its multilinear extension.

-- TODO: define an `OracleInterface.ofEquiv` definition that transfers the oracle interface across
-- an equivalence of types.
instance : OracleInterface (Witness R pp) where
  Query := Fin pp.‚Ñì_w ‚Üí R
  Response := R
  oracle := fun ùï® evalPoint => (MLE (ùï® ‚àò finFunctionFinEquiv)) ‚∏®evalPoint‚∏©

/-!
  ## First message
  We invoke the protocol `SendSingleWitness` to send the witness `ùï®` to the verifier.
-/

/-- Unfolds to `ùï© : Fin (2 ^ ‚Ñì_n - 2 ^ ‚Ñì_w) ‚Üí R` -/
@[simp]
abbrev Statement.AfterFirstMessage : Type := Statement R pp

/-- Unfolds to `A, B, C : Matrix (Fin 2 ^ ‚Ñì_m) (Fin 2 ^ ‚Ñì_n) R` and `ùï® : Fin 2 ^ ‚Ñì_w ‚Üí R` -/
@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  (OracleStatement R pp) ‚äï·µ• (fun _ => Witness R pp)

/-- Unfolds to `() : Unit` -/
@[simp]
abbrev Witness.AfterFirstMessage : Type := Unit

def oracleReduction.firstMessage :
    OracleReduction oSpec
      (Statement R pp) (OracleStatement R pp) (Witness R pp)
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) Unit
      ![(.P_to_V, Witness R pp)] :=
  SendSingleWitness.oracleReduction oSpec
    (Statement R pp) (OracleStatement R pp) (Witness R pp)

/-!
  ## First challenge
  We invoke the protocol `RandomQuery` on the "virtual" polynomial:
    `ùí¢(Z) = ‚àë_{x} eq ‚∏®Z, x‚∏© * (Aùï´ ‚∏®x‚∏© * Bùï´ ‚∏®x‚∏© - Cùï´ ‚∏®x‚∏©)`, which is supposed to be `0`.
-/

def zeroCheckVirtualPolynomial (ùï© : Statement.AfterFirstMessage R pp)
    -- Recall: `oStmt = (A, B, C, ùï®)`
    (oStmt : ‚àÄ i, OracleStatement.AfterFirstMessage R pp i) :
      MvPolynomial (Fin pp.‚Ñì_m) R :=
  letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
  ‚àë x : Fin (2 ^ pp.‚Ñì_m),
    (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_m ‚Üí R)) *
      C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

/-- Unfolds to `œÑ : Fin ‚Ñì_m ‚Üí R` -/
@[simp]
abbrev FirstChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

/-- Unfolds to `(œÑ, x) : (Fin (2 ^ ‚Ñì_n - 2 ^ ‚Ñì_w) ‚Üí R) √ó (Fin (2 ^ ‚Ñì_m) ‚Üí R)` -/
@[simp]
abbrev Statement.AfterFirstChallenge : Type :=
  FirstChallenge R pp √ó Statement.AfterFirstMessage R pp

/-- Is equivalent to `((A, B, C), ùï®) :`
  `(fun _ => (Matrix (Fin 2 ^ ‚Ñì_m) (Fin 2 ^ ‚Ñì_n) R)) √ó (Fin 2 ^ ‚Ñì_w ‚Üí R)` -/
@[simp]
abbrev OracleStatement.AfterFirstChallenge : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstMessage R pp

@[simp]
abbrev Witness.AfterFirstChallenge : Type := Unit

def oracleReduction.firstChallenge :
    OracleReduction oSpec
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) (Witness R pp)
      (Statement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstChallenge R pp) Unit
      ![(.V_to_P, FirstChallenge R pp)] :=
  sorry
  -- (RandomQuery.oracleReduction oSpec (Statement.AfterFirstMessage R pp)).liftContext sorry

/-!
  ## First sum-check
  We invoke the sum-check protocol the "virtual" polynomial:
    `‚Ñ±(X) = eq ‚∏®œÑ, X‚∏© * (A ‚∏®X‚∏© * B ‚∏®X‚∏© - C ‚∏®X‚∏©)`
-/

-- def firstSumCheckVirtualPolynomial (ùï© : FirstMessageStatement R pp)
--     (oStmt : ‚àÄ i, FirstMessageOracleStatement R pp i) : MvPolynomial (Fin pp.‚Ñì_n) R :=
--   letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
--   ‚àë x : Fin (2 ^ pp.‚Ñì_n),
--     (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_n ‚Üí R)) *
--       C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

/-- Unfolds to `r_x : Fin ‚Ñì_m ‚Üí R` -/
@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

/-- Unfolds to `(r_x, œÑ, ùï©) : (Fin ‚Ñì_m ‚Üí R) √ó (Fin (2 ^ ‚Ñì_n - 2 ^ ‚Ñì_w) ‚Üí R) √ó (Fin ‚Ñì_m ‚Üí R)` -/
@[simp]
abbrev Statement.AfterFirstSumcheck : Type :=
  FirstSumcheckChallenge R pp √ó Statement.AfterFirstChallenge R pp

/-- Is equivalent to `((A, B, C), ùï®) :`
  `(fun _ => (Matrix (Fin 2 ^ ‚Ñì_m) (Fin 2 ^ ‚Ñì_n) R)) √ó (Fin 2 ^ ‚Ñì_w ‚Üí R)` -/
@[simp]
abbrev OracleStatement.AfterFirstSumcheck : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstChallenge R pp

@[simp]
abbrev Witness.AfterFirstSumcheck : Type := Unit

-- def oracleReduction.firstSumcheck :
--     OracleReduction (Sumcheck.Spec.pSpec R pp.‚Ñì_m) oSpec
--       (Statement.AfterFirstChallenge R pp) Witness.AfterFirstChallenge
--       (Statement.AfterFirstSumcheck R pp) Witness.AfterFirstSumcheck
--       (OracleStatement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstSumcheck R pp) :=
  -- Sumcheck.Spec.oracleReduction oSpec
  --   (Statement.AfterFirstChallenge R pp) (Witness.AfterFirstChallenge R pp)
  --   (Statement.AfterFirstSumcheck R pp) (Witness.AfterFirstSumcheck R pp)
  --   (OracleStatement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstSumcheck R pp)

/-!
  ## Send evaluation claims

  We send the evaluation claims `v_A, v_B, v_C` to the verifier.

  (i.e. invoking `SendClaim` on these "virtual" values)
-/

@[simp]
abbrev EvalClaim : R1CS.MatrixIdx ‚Üí Type := fun _ => R

/-- We equip each evaluation claim with the default oracle interface, which returns the claim upon a
  trivial query `() : Unit`. -/
instance : ‚àÄ i, OracleInterface (EvalClaim R i) :=
  fun _ => default

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

@[simp]
abbrev OracleStatement.AfterSendEvalClaim : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  EvalClaim R ‚äï·µ• OracleStatement.AfterFirstSumcheck R pp

@[simp]
abbrev Witness.AfterSendEvalClaim : Type := Unit

def oracleReduction.sendEvalClaim :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterSendEvalClaim R pp) (OracleStatement.AfterSendEvalClaim R pp) Unit
      ![(.P_to_V, ‚àÄ i, EvalClaim R i)] :=
  sorry
  -- SendClaim.oracleReduction oSpec
  --   (Statement.AfterFirstSumcheck R pp)

/-!
  ## Random linear combination challenges

  The verifier sends back random linear combination challenges `r_A, r_B, r_C : R`.
-/

@[simp]
abbrev LinearCombinationChallenge : Type := R1CS.MatrixIdx ‚Üí R

/-- Unfolds to `((r_A, r_B, r_C), r_x, œÑ, ùï©) :`
  `(R1CS.MatrixIdx ‚Üí R) √ó (Fin (2 ^ ‚Ñì_m) ‚Üí R) √ó (Fin ‚Ñì_m ‚Üí R) √ó (Fin (2 ^ ‚Ñì_n - 2 ^ ‚Ñì_w) ‚Üí R)` -/
@[simp]
abbrev Statement.AfterLinearCombination : Type :=
  LinearCombinationChallenge R √ó Statement.AfterSendEvalClaim R pp

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  EvalClaim R ‚äï·µ• OracleStatement.AfterFirstSumcheck R pp

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

instance : ‚àÄ i, OracleInterface (ProtocolSpec.Message ![(.V_to_P, LinearCombinationChallenge R)] i)
  | ‚ü®0, h‚ü© => nomatch h

def oracleReduction.linearCombination :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterLinearCombination R pp) (OracleStatement.AfterLinearCombination R pp) Unit
      ![(.V_to_P, LinearCombinationChallenge R)] :=
  sorry

/-!
  ## Second sum-check
  We invoke the sum-check protocol the "virtual" polynomial:
    `‚Ñ≥(Y) = r_A * (MLE A) ‚∏®r_x, Y‚∏© * (MLE ùï´) ‚∏®Y‚∏© + r_B * (MLE B) ‚∏®r_x, Y‚∏© * (MLE ùï´) ‚∏®Y‚∏©`
      `+ r_C * (MLE C) ‚∏®r_x, Y‚∏© * (MLE ùï´) ‚∏®Y‚∏©`
-/

def secondSumCheckVirtualPolynomial
    (stmt : Statement.AfterLinearCombination R pp)
    (oStmt : ‚àÄ i, OracleStatement.AfterLinearCombination R pp i) :
      MvPolynomial (Fin pp.‚Ñì_n) R := sorry

@[simp]
abbrev SecondSumcheckChallenge : Type := Fin pp.‚Ñì_n ‚Üí R

/-- Unfolds to `(r_y, (r_A, r_B, r_C), r_x, œÑ, ùï©) :`
  `(Fin ‚Ñì_n ‚Üí R) √ó (R1CS.MatrixIdx ‚Üí R) √ó (Fin (2 ^ ‚Ñì_m) ‚Üí R) √ó (Fin ‚Ñì_m ‚Üí R) √ó`
  `(Fin (2 ^ ‚Ñì_n - 2 ^ ‚Ñì_w) ‚Üí R)` -/
@[simp]
abbrev Statement.AfterSecondSumcheck : Type :=
  SecondSumcheckChallenge R pp √ó Statement.AfterLinearCombination R pp

@[simp]
abbrev OracleStatement.AfterSecondSumcheck : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  EvalClaim R ‚äï·µ• OracleStatement.AfterFirstSumcheck R pp

@[simp]
abbrev Witness.AfterSecondSumcheck : Type := Unit

-- def oracleReduction.secondSumcheck :
--     OracleReduction (Sumcheck.Spec.pSpec R pp.‚Ñì_n) oSpec
--       (Statement.AfterLinearCombination R pp) Witness.AfterLinearCombination
--       (Statement.AfterSecondSumcheck R pp) Witness.AfterSecondSumcheck
--       (OracleStatement.AfterLinearCombination R pp) (OracleStatement.AfterSecondSumcheck R pp) :=
--   sorry

/-!
  ## Final check

  We invoke the `CheckClaim` protocol to check the two evaluation claims.
-/

-- Definition of the final relation to be checked
-- def finalCheck := sorry

-- def oracleReduction.finalCheck :
--     OracleReduction ![] oSpec
--       (Statement.AfterSecondSumcheck R pp) Witness.AfterSecondSumcheck
--       Unit Unit
--       (OracleStatement.AfterSecondSumcheck R pp) (fun _ => Unit) :=
--   CheckClaim.oracleReduction oSpec (Statement.AfterSecondSumcheck R pp)
--     (OracleStatement.AfterSecondSumcheck R pp) (sorry)

end Construction

section Security


end Security

end Spec

end

end Spartan
