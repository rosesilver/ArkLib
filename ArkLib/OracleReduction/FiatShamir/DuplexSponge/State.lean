/-
Copyright (c) 2024-2025 ArkLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import ArkLib.Data.Hash.DomainSep

/-!
  # State of the Prover and Verifier in Duplex Sponge Fiat-Shamir

  This file contains the implementation of prover and verifier states for interactive proofs
  using duplex sponge functions, based on the [spongefish](https://github.com/arkworks-rs/spongefish)
  Rust library.

  ## Core Components

  - `HashStateWithInstructions`: A stateful hash object that interfaces with duplex sponges
  - `VerifierState`: The verifier state containing hash state and NARG string
  - `ProverState`: The prover state containing randomness, hash state, and transcript
  - `ProverPrivateRng`: Cryptographically-secure RNG bound to the protocol transcript

  NOTE: this file is generated by Claude 4 Sonnet and has not been fully proof-read.
-/

-- Hack: define `Repr` instance for `ByteArray` in terms of the `Repr` instance for `List`
instance : Repr ByteArray where
  reprPrec b n := List.repr b.toList n

/-- A stateful hash object that interfaces with duplex sponges.

Rust interface:
```rust
#[derive(Clone)]
pub struct HashStateWithInstructions<H, U = u8>
where
    U: Unit,
    H: DuplexSpongeInterface<U>,
{
    /// The internal duplex sponge used for absorbing and squeezing data.
    ds: H,
    /// A stack of expected sponge operations.
    stack: VecDeque<Op>,
    /// Marker to associate the unit type `U` without storing a value.
    _unit: PhantomData<U>,
}
```

This structure maintains the sponge state and tracks expected operations to ensure
protocol compliance.
-/
structure HashStateWithInstructions (U : Type) [SpongeUnit U] (H : Type*)
    [DuplexSpongeInterface U H] where
  /-- The internal duplex sponge used for absorbing and squeezing data. -/
  ds : H
  /-- A stack of expected sponge operations (FIFO queue). -/
  stack : Array DomainSeparator.Op
deriving Inhabited, DecidableEq, Repr

namespace HashStateWithInstructions

variable {U : Type} {H : Type*} [SpongeUnit U] [DuplexSpongeInterface U H]

/-- Generate a 32-byte tag from the domain separator bytes using Keccak.

Rust implementation:
```rust
fn generate_tag(iop_bytes: &[u8]) -> [u8; 32] {
    let mut keccak = Keccak::default();
    keccak.absorb_unchecked(iop_bytes);
    let mut tag = [0u8; 32];
    keccak.squeeze_unchecked(&mut tag);
    tag
}
```
-/
def generateTag (iopBytes : ByteArray) : Vector UInt8 32 :=
  -- TODO: Implement Keccak hashing
  sorry

/-- Initialize a stateful hash object from a domain separator.

Rust interface:
```rust
pub fn new(domain_separator: &DomainSeparator<H, U>) -> Self
```
-/
def new (domainSeparator : DomainSeparator U H) : HashStateWithInstructions U H :=
  let stack := domainSeparator.finalize
  let tag := generateTag domainSeparator.asBytes
  { ds := Initialize.new tag, stack := stack }

/-- Perform secure absorption of elements into the sponge.

Rust interface:
```rust
pub fn absorb(&mut self, input: &[U]) -> Result<(), DomainSeparatorMismatch>
```
-/
def absorb (state : HashStateWithInstructions U H) (input : Array U) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  -- TODO: Fix implementation with proper interface calls and array bounds checking
  sorry

/-- Perform a secure squeeze operation.

Rust interface:
```rust
pub fn squeeze(&mut self, output: &mut [U]) -> Result<(), DomainSeparatorMismatch>
```
-/
def squeeze (state : HashStateWithInstructions U H) (outputSize : Nat) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H × Array U) := do
  -- TODO: Fix implementation with proper interface calls and array bounds checking
  sorry

/-- Process a hint operation.

Rust interface:
```rust
pub fn hint(&mut self) -> Result<(), DomainSeparatorMismatch>
```
-/
def hint (state : HashStateWithInstructions U H) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  -- TODO: Fix implementation with proper array bounds checking
  sorry

/-- Perform a ratchet operation.

Rust interface:
```rust
pub fn ratchet(&mut self) -> Result<(), DomainSeparatorMismatch>
```
-/
def ratchet (state : HashStateWithInstructions U H) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  -- TODO: Fix implementation with proper interface calls and array bounds checking
  sorry

end HashStateWithInstructions

/-- The verifier state for interactive proofs.

Rust interface:
```rust
pub struct VerifierState<'a, H = DefaultHash, U = u8>
where
    H: DuplexSpongeInterface<U>,
    U: Unit,
{
    pub(crate) hash_state: HashStateWithInstructions<H, U>,
    pub(crate) narg_string: &'a [u8],
}
```

The verifier state contains a hash state and a reference to the NARG string
(Non-interactive ARGument string) containing the proof transcript.
-/
structure FSVerifierState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
  /-- The hash state tracking expected operations. -/
  hashState : HashStateWithInstructions U H
  /-- The NARG string containing the proof transcript. -/
  nargString : ByteArray
deriving Repr

namespace FSVerifierState

variable {U : Type} {H : Type*} [SpongeUnit U] [DuplexSpongeInterface U H]

/-- Create a new VerifierState from a domain separator and NARG string.

Rust interface:
```rust
pub fn new(domain_separator: &DomainSeparator<H, U>, narg_string: &'a [u8]) -> Self
```
-/
def new (domainSeparator : DomainSeparator U H) (nargString : ByteArray) :
    FSVerifierState U H :=
  { hashState := HashStateWithInstructions.new domainSeparator,
    nargString := nargString }

/-- Read units from the NARG string and absorb them.

Rust interface:
```rust
pub fn fill_next_units(&mut self, input: &mut [U]) -> Result<(), DomainSeparatorMismatch>
```
-/
def fillNextUnits (state : FSVerifierState U H) (count : Nat) :
    Except DomainSeparatorMismatch (FSVerifierState U H × Array U) := do
  -- Check if we have enough bytes in the NARG string
  let bytesNeeded := count * HasSize.size U UInt8
  if state.nargString.size < bytesNeeded then
    .error {
      message := s!"Insufficient transcript remaining, need {bytesNeeded} bytes,
        got {state.nargString.size}" }
  else
    -- Read the required bytes
    let readBytes := state.nargString.extract 0 bytesNeeded
    let remaining := state.nargString.extract bytesNeeded state.nargString.size
    -- Deserialize units from bytes
    let units := Array.range count |>.mapM (fun i =>
      let unitBytes := readBytes.extract (i * HasSize.size U UInt8) (HasSize.size U UInt8)
      DeserializeOption.deserialize unitBytes)
    match units with
    | some unitsArray =>
      -- Absorb into hash state
      let newHashState ← state.hashState.absorb unitsArray
      .ok ({ hashState := newHashState, nargString := remaining }, unitsArray)
    | none =>
      .error { message := "Failed to deserialize units from NARG string" }

/-- Read a hint from the NARG string.

Rust interface:
```rust
pub fn hint_bytes(&mut self) -> Result<&'a [u8], DomainSeparatorMismatch>
```
-/
def hintBytes (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H × ByteArray) := do
  let newHashState ← state.hashState.hint

    -- Ensure at least 4 bytes are available for the length prefix
  if state.nargString.size < 4 then
    .error { message := "Insufficient transcript remaining for hint" }
  else
    -- Read 4-byte little-endian length prefix explicitly
    let byte0 := state.nargString[0]!.toNat
    let byte1 := state.nargString[1]!.toNat
    let byte2 := state.nargString[2]!.toNat
    let byte3 := state.nargString[3]!.toNat
    let length := byte0 + (byte1 <<< 8) + (byte2 <<< 16) + (byte3 <<< 24)
    let rest := state.nargString.extract 4 state.nargString.size

    -- Ensure the rest of the slice has `length` bytes
    if rest.size < length then
      .error { message := s!"Insufficient transcript remaining, got {rest.size}, need {length}" }
    else
      -- Split the hint and advance the transcript
      let hint := rest.extract 0 length
      let remaining := rest.extract length rest.size
      .ok ({ hashState := newHashState, nargString := remaining }, hint)

/-- Signal the end of statement with ratcheting.

Rust interface:
```rust
pub fn ratchet(&mut self) -> Result<(), DomainSeparatorMismatch>
```
-/
def ratchet (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H) := do
  let newHashState ← state.hashState.ratchet
  .ok { hashState := newHashState, nargString := state.nargString }

end FSVerifierState

/-- A cryptographically-secure random number generator bound to the protocol transcript.

Rust interface:
```rust
pub struct ProverPrivateRng<R: RngCore + CryptoRng> {
    /// The duplex sponge that is used to generate the random coins.
    pub(crate) ds: Keccak,
    /// The cryptographic random number generator that seeds the sponge.
    pub(crate) csrng: R,
}
```

This ensures that the prover's randomness is deterministically derived from the protocol
transcript while being seeded by a cryptographically secure source.
-/
structure ProverPrivateRng (R : Type*) where
  /-- The duplex sponge for generating random coins. -/
  ds : Unit -- TODO: Replace with actual Keccak type
  /-- The cryptographic random number generator seed. -/
  csrng : R
deriving Repr

/-- The prover state for interactive proofs.

Rust interface:
```rust
pub struct ProverState<H = DefaultHash, U = u8, R = DefaultRng>
where
    U: Unit,
    H: DuplexSpongeInterface<U>,
    R: RngCore + CryptoRng,
{
    /// The randomness state of the prover.
    pub(crate) rng: ProverPrivateRng<R>,
    /// The public coins for the protocol
    pub(crate) hash_state: HashStateWithInstructions<H, U>,
    /// The encoded data.
    pub(crate) narg_string: Vec<u8>,
}
```

The Fiat-Shamir prover state maintains secret randomness, tracks the protocol state, and builds
the proof transcript.
-/
structure FSProverState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H]
    (R : Type*) where
  /-- The randomness state of the prover. -/
  rng : ProverPrivateRng R
  /-- The public coins for the protocol. -/
  hashState : HashStateWithInstructions U H
  /-- The encoded proof transcript. -/
  nargString : ByteArray
deriving Repr

namespace FSProverState

variable {U : Type} {H : Type*} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H]

/-- Create a new `FSProverState` from a domain separator and RNG.

Rust interface:
```rust
pub fn new(domain_separator: &DomainSeparator<H, U>, csrng: R) -> Self
```
-/
def new (domainSeparator : DomainSeparator U H) (csrng : R) : FSProverState U H R :=
  let hashState := HashStateWithInstructions.new domainSeparator
  -- TODO: Initialize ProverPrivateRng properly
  let rng : ProverPrivateRng R := { ds := (), csrng := csrng }
  { rng := rng, hashState := hashState, nargString := ByteArray.empty }

/-- Add units to the protocol transcript.

Rust interface:
```rust
pub fn add_units(&mut self, input: &[U]) -> Result<(), DomainSeparatorMismatch>
```
-/
def addUnits (state : FSProverState U H R) (input : Array U) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.absorb input with
  | .ok newHashState =>
    -- TODO: Serialize units and append to NARG string
    -- TODO: Update RNG with new transcript data
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

/-- Add a hint to the protocol transcript.

Rust interface:
```rust
pub fn hint_bytes(&mut self, hint: &[u8]) -> Result<(), DomainSeparatorMismatch>
```
-/
def hintBytes (state : FSProverState U H R) (hint : ByteArray) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.hint with
  | .ok newHashState =>
    -- TODO: Add length prefix and hint to NARG string
    -- let len = u32::try_from(hint.len()).expect("Hint size out of bounds");
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

/-- Ratchet the protocol state.

Rust interface:
```rust
pub fn ratchet(&mut self) -> Result<(), DomainSeparatorMismatch>
```
-/
def ratchet (state : FSProverState U H R) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.ratchet with
  | .ok newHashState =>
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

/-- Get the current NARG string (proof transcript).

Rust interface:
```rust
pub fn narg_string(&self) -> &[u8]
```
-/
def getNargString (state : FSProverState U H R) : ByteArray := state.nargString

end FSProverState

/-- Type class for unit transcript operations.

Rust interface:
```rust
pub trait UnitTranscript<U> {
    fn public_units(&mut self, input: &[U]) -> Result<(), DomainSeparatorMismatch>;
    fn fill_challenge_units(&mut self, input: &mut [U]) -> Result<(), DomainSeparatorMismatch>;
}
```
-/
class UnitTranscript (α : Type*) (U : Type) where
  /-- Add public units without writing to transcript. -/
  publicUnits : α → Array U → Except DomainSeparatorMismatch α
  /-- Fill array with challenge units. -/
  fillChallengeUnits : α → Nat → Except DomainSeparatorMismatch (α × Array U)

/-- UnitTranscript instance for FSVerifierState. -/
instance {U : Type} {H : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSVerifierState U H) U where
  publicUnits state input := do
    let newHashState ← state.hashState.absorb input
    .ok { hashState := newHashState, nargString := state.nargString }
  fillChallengeUnits state count := do
    let (newHashState, output) ← state.hashState.squeeze count
    .ok ({ hashState := newHashState, nargString := state.nargString }, output)

/-- UnitTranscript instance for FSProverState. -/
instance {U : Type} {H : Type*} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSProverState U H R) U where
  publicUnits state input := do
    -- Public units are absorbed but not added to transcript
    -- let oldNargLen := state.nargString.size
    let newState ← state.addUnits input
    .ok { rng := newState.rng, hashState := newState.hashState,
          nargString := state.nargString } -- Keep old NARG string
  fillChallengeUnits state count :=
    match state.hashState.squeeze count with
    | .ok (newHashState, output) =>
      .ok ({ rng := state.rng, hashState := newHashState, nargString := state.nargString }, output)
    | .error e => .error e

namespace DomainSeparator

variable {H : Type*} {U : Type} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H]

/-- Create a ProverState from this domain separator.

Rust interface:
```rust
pub fn to_prover_state(&self) -> crate::ProverState<H, U, crate::DefaultRng>
```
-/
def toProverState (ds : DomainSeparator U H) (rng : R) : FSProverState U H R :=
  FSProverState.new ds rng

/-- Create a FSVerifierState from this domain separator and transcript.

Rust interface:
```rust
pub fn to_verifier_state<'a>(&self, transcript: &'a [u8]) -> crate::VerifierState<'a, H, U>
```
-/
def toVerifierState (ds : DomainSeparator U H) (transcript : ByteArray) : FSVerifierState U H :=
  FSVerifierState.new ds transcript

end DomainSeparator
