\section{The Fiat-Shamir Transformation}\label{sec:fiat_shamir}

(NOTE: generated by Claude 4 Sonnet, will need to be cleaned up)

The Fiat-Shamir transformation is a fundamental cryptographic technique that converts a public-coin interactive reduction into a non-interactive reduction by replacing verifier challenges with queries to a random oracle. This transformation removes the need for interaction while preserving important security properties under certain assumptions.

In our formalization, the Fiat-Shamir transformation takes an interactive reduction $R$ and produces a non-interactive reduction where the prover computes all messages at once, and the verifier derives the challenges using queries to a hash function (modeled as a random oracle) applied to the statement and the messages up to each challenge round.

\subsection{Oracle Interface for Fiat-Shamir Challenges}\label{sec:fiat_shamir_oracle_interface}

The key insight of the Fiat-Shamir transformation is to replace interactive challenges with deterministic computations based on the protocol messages so far.

\begin{definition}[Fiat-Shamir Challenge Oracle Interface]
    \label{def:fiat_shamir_challenge_oracle_interface}
    For a protocol specification $\pSpec$ and input statement type $\StmtIn$, the Fiat-Shamir challenge oracle interface for the $i$-th challenge is defined as follows:
    \begin{itemize}
        \item \textbf{Query type}: $\StmtIn \times \pSpec.\MessagesUpTo \;i.\mathsf{val}.\mathsf{castSucc}$
        \item \textbf{Response type}: $\pSpec.\Challenge \;i$
        \item \textbf{Oracle behavior}: Returns the challenge (which is determined by the random oracle)
    \end{itemize}

    The query consists of the input statement and all prover messages sent up to (but not including) round $i$.
    % \lean{instChallengeOracleInterfaceFiatShamir}
\end{definition}

\begin{definition}[Fiat-Shamir Oracle Specification]
    \label{def:fiat_shamir_spec}
    The Fiat-Shamir oracle specification for a protocol $\pSpec$ with input statement type $\StmtIn$ is:
    \[ \mathsf{fiatShamirSpec} \;\pSpec \;\StmtIn : \OracleSpec \;\pSpec.\ChallengeIdx \]
    where for each challenge index $i$, the oracle domain is $\StmtIn \times \pSpec.\MessagesUpTo \;i.\mathsf{val}.\mathsf{castSucc}$ and the range is $\pSpec.\Challenge \;i$.

    This specification defines a family of oracles, one for each challenge round, that deterministically computes challenges based on the statement and messages up to that round.
    \lean{ProtocolSpec.fiatShamirSpec}
\end{definition}

\subsection{Fiat-Shamir Transformation for Provers}\label{sec:fiat_shamir_prover}

The Fiat-Shamir transformation modifies the prover's execution to compute all messages non-interactively while simulating the verifier's challenges using oracle queries.

\begin{definition}[Fiat-Shamir Round Processing]
    \label{def:prover_process_round_fs}
    The modified round processing function for Fiat-Shamir maintains the prover messages (but not challenges) and the input statement throughout execution:

    \[ \mathsf{processRoundFS} \;j \;\mathsf{prover} \;\mathsf{currentResult} \]

    For each round $j$:
    \begin{itemize}
        \item If $j$ is a challenge round: Query the Fiat-Shamir oracle with the statement and messages so far, then update the prover state with the received challenge
        \item If $j$ is a message round: Generate the message using the prover's $\mathsf{sendMessage}$ function and append it to the message history
    \end{itemize}

    The key difference from standard execution is that challenges are derived via oracle queries rather than received from an interactive verifier.
    \lean{Prover.processRoundFS}
    \uses{def:fiat_shamir_spec}
\end{definition}

\begin{definition}[Fiat-Shamir Prover Execution]
    \label{def:prover_run_to_round_fs}
    The Fiat-Shamir prover execution up to round $i$ is defined as:

    \[ \mathsf{runToRoundFS} \;i \;\mathsf{stmt} \;\mathsf{prover} \;\mathsf{state} \]

    This executes the prover inductively using $\mathsf{processRoundFS}$, starting from the initial state and accumulating messages and the statement. Returns the messages up to round $i$, the input statement, and the prover's final state.
    \lean{Prover.runToRoundFS}
    \uses{def:prover_process_round_fs}
\end{definition}

\begin{definition}[Fiat-Shamir Prover Transformation]
    \label{def:prover_fiat_shamir}
    Given an interactive prover $P$ for protocol $\pSpec$, the Fiat-Shamir transformation produces a non-interactive prover:

    \[ P.\mathsf{fiatShamir} : \NonInteractiveProver \;(\forall i, \pSpec.\Message \;i) \;(\oSpec \mathrel{++_\mathsf{o}} \mathsf{srChallengeOracle} \;\pSpec \;\StmtIn) \;\StmtIn \;\WitIn \;\StmtOut \;\WitOut \]

    The transformed prover:
    \begin{itemize}
        \item Has state type that combines the statement with the original prover's state at round 0, and uses the final state type for subsequent rounds
        \item On input, stores both the statement and initializes the original prover's state
        \item Sends a single message containing all of the original prover's messages, computed via $\mathsf{runToRoundFS}$
        \item Never receives challenges (since it's non-interactive)
        \item Outputs using the original prover's output function
    \end{itemize}
    \lean{Prover.fiatShamir}
    \uses{def:prover_run_to_round_fs}
\end{definition}

\subsection{Transcript Derivation and Verifier Transformation}\label{sec:fiat_shamir_verifier}

The Fiat-Shamir verifier must reconstruct the full interactive transcript from the prover's messages in order to run the original verification logic.

\begin{definition}[Fiat-Shamir Transcript Derivation]
    \label{def:derive_transcript_fs}
    Given a collection of prover messages and an input statement, the function $\mathsf{deriveTranscriptFS}$ reconstructs the full protocol transcript up to round $k$:

    \[ \mathsf{messages}.\mathsf{deriveTranscriptFS} \;\mathsf{stmt} \;k : \OracleComp \;(\oSpec \mathrel{++_\mathsf{o}} \mathsf{srChallengeOracle} \;\pSpec \;\StmtIn) \;(\pSpec.\Transcript \;k) \]

    This is computed inductively:
    \begin{itemize}
        \item For challenge rounds: Query the Fiat-Shamir oracle with the statement and messages up to that point
        \item For message rounds: Use the corresponding message from the prover
    \end{itemize}

    The result is a complete transcript that includes both prover messages and verifier challenges.
    \lean{ProtocolSpec.Messages.deriveTranscriptFS}
    \uses{def:fiat_shamir_spec}
\end{definition}

\begin{definition}[Fiat-Shamir Verifier Transformation]
    \label{def:verifier_fiat_shamir}
    Given an interactive verifier $V$ for protocol $\pSpec$, the Fiat-Shamir transformation produces a non-interactive verifier:

    \[ V.\mathsf{fiatShamir} : \NonInteractiveVerifier \;(\forall i, \pSpec.\Message \;i) \;(\oSpec \mathrel{++_\mathsf{o}} \mathsf{srChallengeOracle} \;\pSpec \;\StmtIn) \;\StmtIn \;\StmtOut \]

    The transformed verifier:
    \begin{itemize}
        \item Takes the input statement and a proof consisting of all prover messages
        \item Derives the full transcript using $\mathsf{deriveTranscriptFS}$
        \item Runs the original verifier's verification logic on the reconstructed transcript
    \end{itemize}
    \lean{Verifier.fiatShamir}
    \uses{def:derive_transcript_fs}
\end{definition}

\subsection{Fiat-Shamir Transformation for Reductions}\label{sec:fiat_shamir_reduction}

\begin{definition}[Fiat-Shamir Reduction Transformation]
    \label{def:reduction_fiat_shamir}
    Given an interactive reduction $R$ for protocol $\pSpec$, the Fiat-Shamir transformation produces a non-interactive reduction:

    \[ R.\mathsf{fiatShamir} : \NonInteractiveReduction \;(\forall i, \pSpec.\Message \;i) \;(\oSpec \mathrel{++_\mathsf{o}} \mathsf{srChallengeOracle} \;\pSpec \;\StmtIn) \;\StmtIn \;\WitIn \;\StmtOut \;\WitOut \]

    This transformation simply applies the Fiat-Shamir transformation to both the prover and verifier components of the reduction.
    \lean{Reduction.fiatShamir}
    \uses{def:prover_fiat_shamir, def:verifier_fiat_shamir}
\end{definition}

\subsection{Security Properties}\label{sec:fiat_shamir_security}

The Fiat-Shamir transformation preserves important security properties of the original interactive reduction, under appropriate assumptions about the random oracle.

\begin{theorem}[Fiat-Shamir Preserves Completeness]
    \label{thm:fiat_shamir_completeness}
    Let $R$ be an interactive reduction with completeness error $\epsilon$ with respect to input relation $R_{\text{in}}$ and output relation $R_{\text{out}}$. Then the Fiat-Shamir transformed reduction $R.\mathsf{fiatShamir}$ also satisfies completeness with error $\epsilon$ with respect to the same relations.

    Formally: $R.\mathsf{completeness} \;R_{\text{in}} \;R_{\text{out}} \;\epsilon \to (R.\mathsf{fiatShamir}).\mathsf{completeness} \;R_{\text{in}} \;R_{\text{out}} \;\epsilon$
    \lean{fiatShamir_completeness}
    \uses{def:reduction_fiat_shamir}
\end{theorem}

\begin{remark}[Additional Security Properties]
    While completeness is straightforward to establish, soundness properties require more careful analysis. In particular:
    \begin{itemize}
        \item State-restoration knowledge soundness of the original reduction implies knowledge soundness of the Fiat-Shamir transformed reduction
        \item Honest-verifier zero-knowledge of the original reduction implies zero-knowledge of the transformed reduction
    \end{itemize}
    These results require the random oracle model and careful handling of the oracle programming needed for simulation and extraction. The formal statements and proofs of these results are currently under development.
\end{remark}

\begin{remark}[Implementation Considerations]
    Our formalization models the "theoretical" version of Fiat-Shamir where the entire statement and transcript prefix are hashed to derive each challenge. In practice, more efficient variants use cryptographic sponges or other techniques to incrementally absorb transcript elements and squeeze out challenges. Our theoretical model provides the foundation for analyzing these practical variants.
\end{remark}
